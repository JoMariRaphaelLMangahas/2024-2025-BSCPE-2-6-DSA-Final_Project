import itertools

class TowerOfHanoi:
    def __init__(self):
        self.towers = {
            'A': [],
            'B': [],
            'C': []
        }
        self.moves = []  # To store the moveset

    def setup(self, disks):
        # Set up the disks in the specified order
        self.towers['A'] = disks
        print("Initial Setup:")
        self.display()

    def move(self, source, destination):
        # Ensure the move follows the rules of Tower of Hanoi
        if not self.towers[source]:
            print(f"Invalid move: {source} is empty.")
            return False

        if not self.towers[destination] or self.towers[source][-1] < self.towers[destination][-1]:
            disk = self.towers[source].pop()  # Move the top disk from source
            self.towers[destination].append(disk)  # Place it on destination
            self.record_move(source, destination)
            return True
        else:
            print(f"Invalid move: Cannot place disk {self.towers[source][-1]} on top of disk {self.towers[destination][-1]}.")
            return False

    def record_move(self, source, destination):
        # Record the move as "Source -> Destination"
        disk = self.towers[destination][-1]
        self.moves.append(f"{source} -> {destination}")
        print(f"Moved disk {disk}: {source} -> {destination}")
        self.display()

    def display(self):
        print("Current Towers State:")
        for tower, disks in self.towers.items():
            print(f"Tower {tower}: {disks}")
        print("-" * 30)

    def solve(self, n, source, target, auxiliary):
        if n == 1:
            self.move(source, target)
        else:
            self.solve(n - 1, source, auxiliary, target)  # Move n-1 disks to auxiliary
            self.move(source, target)  # Move the nth disk to target
            self.solve(n - 1, auxiliary, target, source)  # Move n-1 disks from auxiliary to target

    def validate_end_state(self):
        # Ensure all disks are in Tower C and the count is 5
        if len(self.towers['C']) == 5 and self.towers['C'] == sorted(self.towers['C'], reverse=True):
            return True
        return False

    def show_moveset(self):
        print("\nMoveset:")
        for move in self.moves:
            print(move)


# Calculate success rate over all permutations
def calculate_success_rate():
    total_permutations = 0
    successful_permutations = 0
    failed_permutations = []

    # Generate all permutations of the disks [1, 2, 3, 4, 5]
    for disks in itertools.permutations(range(1, 6)):
        total_permutations += 1
        game = TowerOfHanoi()
        game.setup(list(disks))  # Set up the game with the current permutation
        game.solve(len(game.towers['A']), 'A', 'C', 'B')  # Solve the Tower of Hanoi
        if game.validate_end_state():  # Check if the final state is valid
            successful_permutations += 1
        else:
            failed_permutations.append(list(disks))  # Log the failed permutation
            print(f"Failed permutation: {list(disks)}")
            print("Moves made during this attempt:")
            game.show_moveset()  # Show the moves made for this permutation

    success_rate = (successful_permutations / total_permutations) * 100
    print(f"Total permutations: {total_permutations}")
    print(f"Successful permutations: {successful_permutations}")
    print(f"Success rate: {success_rate:.2f}%")
    print (f"Failed permutations: {failed_permutations}")

# Run the success rate calculation
calculate_success_rate()